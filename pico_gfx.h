/**
    @file pico_gl.h
    @brief A powerful graphics library based on Sokol GFX, written in C99.
*/

#ifndef PICO_GFX_H
#define PICO_GFX_H

#include "sokol_gfx.h"

#include <stdbool.h>
#include <stddef.h>

/**
 * @brief Drawing primitives
 */
typedef enum
{
    PG_POINTS,         //!< Array of points
    PG_LINES,          //!< Each adjacent pair of points forms a line
    PG_LINE_STRIP,     //!< Array of points where every pair forms a lines
    PG_TRIANGLES,      //!< Each adjacent triple forms an individual triangle
    PG_TRIANGLE_STRIP, //!< Array of points where every triple forms a triangle
} pg_primitive_t;

/**
 * @brief Blend factors
 */
typedef enum
{
    PG_ONE,                 //!< (1, 1, 1, 1) (default)
    PG_ZERO,                //!< (0, 0, 0, 0)
    PG_SRC_COLOR,           //!< (src.r, src.g, src.b, src.a)
    PG_ONE_MINUS_SRC_COLOR, //!< (1, 1, 1, 1) - (src.r, src.g, src.b, src.a)
    PG_DST_COLOR,           //!< (dst.r, dst.g, dst.b, dst.a)
    PG_ONE_MINUS_DST_COLOR, //!< (1, 1, 1, 1) - (dst.r, dst.g, dst.b, dst.a)
    PG_SRC_ALPHA,           //!< (src.a, src.a, src.a, src.a)
    PG_ONE_MINUS_SRC_ALPHA, //!< (1, 1, 1, 1) - (src.a, src.a, src.a, src.a)
    PG_DST_ALPHA,           //!< (dst.a, dst.a, dst.a, dst.a)
    PG_ONE_MINUS_DST_ALPHA, //!< (1, 1, 1, 1) - (dst.a, dst.a, dst.a, dst.a)
    PG_FACTOR_COUNT
} pg_blend_factor_t;

/**
 * @brief Blend equations
 */
typedef enum
{
    PG_FUNC_ADD,              //!< result = src * src_factor + dst * dst_factor (default)
    PG_FUNC_SUBTRACT,         //!< result = src * src_factor - dst * dst_factor
    PG_FUNC_REVERSE_SUBTRACT, //!< result = dst * dst_factor - src * src_factor
    PG_EQ_COUNT
} pg_blend_eq_t;

/**
 * @brief Blend mode
 *
 * Completely describes a blend operation.
 */
typedef struct
{
    pg_blend_factor_t color_src; //!< Color source blending factor
    pg_blend_factor_t color_dst; //!< Color dsestination blending factor
    pg_blend_eq_t     color_eq;  //!< Equation for blending colors
    pg_blend_factor_t alpha_src; //!< Alpha source blending factor
    pg_blend_factor_t alpha_dst; //!< Alpha destination blending factor
    pg_blend_eq_t     alpha_eq;  //!< Equation for blending alpha values
} pg_blend_mode_t;

/**
 * @brief A vertex describes a point and the data associated with it (color and
 * texture coordinates)
 */
typedef struct
{
    float pos[3];
    float color[4];
    float uv[2];
} pg_vertex_t;

/**
 * @brief Shader stage
*/
typedef enum
{
    PG_VS_STAGE, //!< Vertex shader stage
    PG_FS_STAGE  //!< Fragment shader stage
} pg_stage_t;

/**
 * @brief Contains core data/state for an instance of the renderer
 */
typedef struct pg_ctx_t pg_ctx_t;

/**
 * @brief Contains render pass data/state
 */
typedef struct pg_pass_t pg_pass_t;

/**
 * @brief Contains render pass data/state
 */
typedef struct pg_pipeline_t pg_pipeline_t;

/**
 * @brief Contains shader data/state
 */
typedef struct pg_shader_t pg_shader_t;

/**
 * @brief Contains texture data/state
 */
typedef struct pg_texture_t pg_texture_t;

/**
 * @brief Contains vertex buffer data/state
 */
typedef struct pg_vbuffer_t pg_vbuffer_t;

/**
 * @brief Loads pico_gfx and sokol_gfx
 *
 * IMPORTANT: A valid graphics context must exist for this function to succeed.
 * This function must be called before any other pico_gfx functions.
 *
 * NOTE: This function calls `sg_setup`.
 */
void pg_init();

/**
 *  @brief Tears down pico_gfx and sokol_gfx
 *
 * NOTE: This function calls `sg_shutdown`
 */
void pg_shutdown();

/**
 * @brief Creates an instance of the renderer
 */
pg_ctx_t* pg_create_context(int window_width, int window_height);

/**
 * @brief Destroys an instance of the renderer
 */
void pg_destroy_context(pg_ctx_t* ctx);

/**
 * @brief Starts a render pass (mandatory)
 */
void pg_begin_pass(pg_ctx_t* ctx, pg_pass_t* pass, bool clear);

/**
 * @brief Ends a render pass (mandatory)
 */
void pg_end_pass();

/**
 * @brief Flush commands
 *
 * Must be called at the end of a frame (after `pg_end_pass`).
*/
void pg_flush(pg_ctx_t* ctx);

/**
 * @brief Pushes the active state onto the stack.
 *
 * State consists of the pipeline, draw color, scissor, and viewport.
 */
void pg_push_state(pg_ctx_t* ctx);

/**
 * @brief Pops a state off the stack and makes it the active state
 */
void pg_pop_state(pg_ctx_t* ctx);

/**
 * @brief Resets the active state to defaults
 */
void pg_reset_state(pg_ctx_t* ctx);

/**
 * @brief Sets the pipeline state
 */
void pg_set_pipeline(pg_ctx_t* ctx, pg_pipeline_t* pipeline);

/**
 * @brief Sets the clear color state
 */
void pg_set_clear_color(pg_ctx_t* ctx, float r, float g, float b, float a);

/**
 * @brief Sets the viewport state
 */
void pg_set_viewport(pg_ctx_t* ctx, int x, int y, int w, int h);

/**
 * @brief Sets the scissor state
 */
void pg_set_scissor(pg_ctx_t* ctx, int x, int y, int w, int h);

/**
 * @brief Instantiates the shader with the give prefix
 */
#define pg_create_shader(prefix)        \
    pg_create_shader_internal(          \
        (pg_shader_internal_t)          \
        {                               \
		    prefix##_shader_desc,       \
		    prefix##_uniformblock_slot, \
        }                               \
    )

/**
 * @brief Destroys a shader
 */
void pg_destroy_shader(pg_shader_t* shader);

/**
 * @brief Returns the default shader
 */
pg_shader_t* pg_get_default_shader(pg_ctx_t* ctx);

/**
 * @brief Returns a shader ID
 */
uint32_t pg_get_shader_id(pg_shader_t* shader);

/**
 * @brief Registers a uniform block
 */
void pg_register_uniform_block(pg_shader_t* shader, char* name, pg_stage_t stage, size_t size);

/**
 * @brief Sets a uniform block
 */
void pg_set_uniform_block(pg_shader_t* shader, char* name, void* data);

pg_pipeline_t* pg_create_pipeline(pg_primitive_t primitive,
                                  bool target,
                                  bool indexed,
                                  pg_shader_t* shader,
                                  const pg_blend_mode_t* blend_mode);

void pg_destroy_pipeline(pg_pipeline_t* pipeline);

/**
 * @brief Creates a texture from a bitmap
 */
pg_texture_t* pg_create_texture(int width, int height,
                                uint8_t* data, size_t size,
                                int mipmaps, bool smooth, bool repeat);

/**
 * @brief Creates a render target
 */
pg_texture_t* pg_create_render_texture(int width, int height,
                                       int mipmaps, bool smooth, bool repeat);

/**
 * @brief Destroys a texture
 */
void pg_destroy_texture(pg_texture_t* texture);

/**
 * @brief Returns a texture ID
 */
uint32_t pg_get_texture_id(pg_texture_t* texture);

/**
 * @brief Gets a texture's dimensions
 */
void pg_get_texture_size(const pg_texture_t* texture, int* width, int* height);

/**
 * @brief Creates a vertex buffer
 */
pg_vbuffer_t* pg_create_vbuffer(const pg_vertex_t* vertices, size_t count);

/**
 * @brief Destroys a vertex buffer
 */
void pg_destroy_vbuffer(pg_vbuffer_t* buffer);

/**
 * @brief Draws a vertex buffer
 */
// TODO: Accept start/count values
void pg_draw_vbuffer(pg_ctx_t* ctx,
                     pg_vbuffer_t* buffer,
                     size_t start, size_t count,
                     pg_texture_t* texture);

/**
 * @brief Draws an array of vertices
 */
void pg_draw_array(pg_ctx_t* ctx,
                   const pg_vertex_t* vertices, size_t count,
                   pg_texture_t* texture);

void pg_draw_indexed_array(pg_ctx_t* ctx,
                           const pg_vertex_t* vertices, size_t vertex_count,
                           const uint32_t* indices, size_t index_count,
                           pg_texture_t* texture);

/*=============================================================================
 * Internals
 *============================================================================*/

typedef struct
{
	const sg_shader_desc* (*get_shader_desc)(sg_backend backend);
	int (*get_uniformblock_slot)(sg_shader_stage stage, const char* ub_name);
} pg_shader_internal_t;

pg_shader_t* pg_create_shader_internal(pg_shader_internal_t internal);

#if !defined(PICO_GFX_ALIGN)
  #if defined(_MSC_VER)
    #define PICO_GFX_ALIGN(a) __declspec(align(a))
  #else
    #define PICO_GFX_ALIGN(a) __attribute__((aligned(a)))
  #endif
#endif

#pragma pack(push,1)
PICO_GFX_ALIGN(16) typedef struct pg_vs_t {
    float u_proj[16];
} pg_vs_t;
#pragma pack(pop)

#endif // PICO_GFX_H

/*=============================================================================
 * Implementation
 *============================================================================*/

#ifdef PICO_GFX_IMPLEMENTATION

#include <string.h>

/*=============================================================================
 * Constants
 *============================================================================*/

#ifndef PICO_GFX_STACK_MAX_SIZE
#define PICO_GFX_STACK_MAX_SIZE 16
#endif

#ifndef PICO_GFX_BUFFER_SIZE
#define PICO_GFX_BUFFER_SIZE 1024
#endif

/*=============================================================================
 * Macros
 *============================================================================*/

#ifdef NDEBUG
    #define PICO_GFX_ASSERT(expr) ((void)0)
#else
    #ifndef PICO_GFX_ASSERT
        #include <assert.h>
        #define PICO_GFX_ASSERT(expr) (assert(expr))
    #endif
#endif

#if !defined(PICO_GFX_MALLOC) || !defined(PICO_GFX_REALLOC) || !defined(PICO_GFX_FREE)
#include <stdlib.h>
#define PICO_GFX_MALLOC(size)       (malloc(size))
#define PICO_GFX_REALLOC(ptr, size) (realloc(ptr, size))
#define PICO_GFX_FREE(ptr)          (free(ptr))
#endif

#ifndef PICO_GFX_LOG
    #include <stdio.h>
    #define  PICO_GFX_LOG(...) (pg_log(__VA_ARGS__))
#endif

/*=============================================================================
 * GFX Static Funtions
 *============================================================================*/

static sg_primitive_type pg_map_primitive(pg_primitive_t primitive);
static sg_blend_factor pg_map_blend_factor(pg_blend_factor_t factor);
static sg_blend_op pg_map_blend_eq(pg_blend_eq_t eq);
static sg_shader_stage pg_map_stage(pg_stage_t stage);

static void pg_log_sg(const char* tag,                // e.g. 'sg'
                      uint32_t log_level,             // 0=panic, 1=error, 2=warn, 3=info
                      uint32_t log_item_id,           // SG_LOGITEM_*
                      const char* message_or_null,    // a message string, may be nullptr in release mode
                      uint32_t line_nr,               // line number in sokol_gfx.h
                      const char* filename_or_null,   // source filename, may be nullptr in release mode
                      void* user_data);

static void pg_log(const char* fmt, ...);

/*=============================================================================
 * Utility
 *============================================================================*/

static size_t pg_str_copy(char* dst, const char* src, size_t n)
{
    return snprintf(dst, n, "%s", src);
}

/*=============================================================================
 * Hashtable
 *============================================================================*/

#ifdef PICO_GFX_32BIT
    typedef uint32_t pg_hash_t;
#else
    typedef uint64_t pg_hash_t;
#endif

typedef struct pg_hashtable_t pg_hashtable_t;
typedef struct pg_hashtable_iterator_t pg_hashtable_iterator_t;
typedef void (*pg_hashtable_iterator_fn)(pg_hashtable_iterator_t* iterator, char* key, void* value);

static pg_hashtable_t* pg_hashtable_new(size_t capacity, size_t key_size, size_t value_size);
static void pg_hashtable_free(pg_hashtable_t* ht);
static size_t pg_hashtable_capacity(const pg_hashtable_t* ht);
static size_t pg_hashtable_size(const pg_hashtable_t* ht);
static void pg_hashtable_init_iterator(pg_hashtable_t* ht, pg_hashtable_iterator_t* iterator);
static bool pg_hashtable_iterator_next(pg_hashtable_iterator_t* iterator, char** key, void** value);
static void pg_hashtable_put(pg_hashtable_t* ht, const char* key, const void* value);
static void* pg_hashtable_get(pg_hashtable_t* ht, const char* key); // const
static bool pg_hashtable_exists(pg_hashtable_t* ht, const char* key);
static void pg_hashtable_remove(pg_hashtable_t* ht, const char* key);

struct pg_hashtable_iterator_t
{
    pg_hashtable_t* ht;
    size_t index;
    size_t count;
};

/*=============================================================================
 * Arena allocator
 *============================================================================*/

typedef struct pg_arena_t pg_arena_t;

static pg_arena_t* pg_arena_new(size_t size);
static void* pg_arena_alloc(pg_arena_t* arena, size_t size);
static void pg_arena_free(pg_arena_t* arena);

/*=============================================================================
 * Default Shader
 *============================================================================*/

static const sg_shader_desc* pg_default_shader_desc(sg_backend backend);
static int pg_default_attr_slot(const char* attr_name);
static int pg_default_image_slot(sg_shader_stage stage, const char* img_name);
static int pg_default_uniformblock_slot(sg_shader_stage stage, const char* ub_name);
static size_t pg_default_uniformblock_size(sg_shader_stage stage, const char* ub_name);
static int pg_default_uniform_offset(sg_shader_stage stage, const char* ub_name, const char* u_name);
static sg_shader_uniform_desc pg_default_uniform_desc(sg_shader_stage stage, const char* ub_name, const char* u_name);

/*=============================================================================
 * GFX Public API implementation
 *============================================================================*/

static void* pg_malloc(size_t size, void* ctx)
{
    (void)ctx;
    return PICO_GFX_MALLOC(size);
}

static void pg_free(void* ptr, void* ctx)
{
    (void)ctx;
    PICO_GFX_FREE(ptr);
}

typedef struct pg_rect_t
{
    int x, y, width, height;
} pg_rect_t;

typedef struct pg_state_t
{
    sg_color       clear_color;
    pg_pipeline_t* pipeline;
    pg_rect_t      viewport;
    pg_rect_t      scissor;
    pg_shader_t*   shader;
} pg_state_t;

struct pg_ctx_t
{
    int window_width;
    int window_height;
    bool indexed;
    sg_buffer buffer;
    sg_buffer index_buffer;
    pg_pass_t* pass;
    pg_shader_t* default_shader;
    pg_pipeline_t* default_pipeline;
    pg_state_t state;
    pg_state_t state_stack[PICO_GFX_STACK_MAX_SIZE];
    int stack_size;
};

struct pg_pass_t
{
    sg_pass handle;
    pg_texture_t* texture;
};

struct pg_pipeline_t
{
    sg_pipeline handle;
    bool indexed;
    pg_shader_t* shader;
};

struct pg_shader_t
{
    const sg_shader_desc* desc;
    sg_shader handle;
    pg_shader_internal_t internal;
    pg_hashtable_t* uniform_blocks;
    pg_arena_t* arena;
};

typedef struct
{
    char       name[32]; //TODO: Define constant?
    pg_stage_t stage;
    void*      data;
    size_t     size;
    bool       dirty;
} pg_uniform_block_t;

struct pg_texture_t
{
    int width, height;
    bool target;
    sg_image handle;
    sg_image depth_handle;
};

struct pg_vbuffer_t
{
    sg_buffer handle;
    size_t count;
};

void pg_init()
{
    sg_setup(&(sg_desc)
    {
        .logger.func = pg_log_sg,
        .allocator =
        {
            .alloc = pg_malloc,
            .free = pg_free,
            .user_data = NULL,
        }
    });
}

void pg_shutdown()
{
    sg_shutdown();
}

pg_ctx_t* pg_create_context(int window_width, int window_height)
{
    pg_ctx_t* ctx = (pg_ctx_t*)PICO_GFX_MALLOC(sizeof(pg_ctx_t));

    memset(ctx, 0, sizeof(pg_ctx_t));

    ctx->window_width  = window_width;
    ctx->window_height = window_height;
    ctx->default_shader = pg_create_shader(pg_default);
    ctx->default_pipeline = pg_create_pipeline(PG_TRIANGLES, false, false, ctx->default_shader, NULL);

    pg_reset_state(ctx);

    ctx->buffer = sg_make_buffer(&(sg_buffer_desc)
    {
        .type  = SG_BUFFERTYPE_VERTEXBUFFER,
        .size  = PICO_GFX_BUFFER_SIZE * sizeof(pg_vertex_t),
        .usage = SG_USAGE_STREAM
    });

    ctx->index_buffer = sg_make_buffer(&(sg_buffer_desc)
    {
        .type  = SG_BUFFERTYPE_INDEXBUFFER,
        .size  = PICO_GFX_BUFFER_SIZE * sizeof(uint32_t),
        .usage = SG_USAGE_STREAM
    });

    return ctx;
}

void pg_destroy_context(pg_ctx_t* ctx)
{
    PICO_GFX_ASSERT(ctx);

    if (ctx->buffer.id != 0)
        sg_destroy_buffer(ctx->buffer);

    if (ctx->index_buffer.id != 0)
        sg_destroy_buffer(ctx->index_buffer);

    pg_destroy_shader(ctx->default_shader);

    PICO_GFX_FREE(ctx);
}

pg_pass_t* pg_create_pass(pg_texture_t* texture)
{
    PICO_GFX_ASSERT(texture);
    PICO_GFX_ASSERT(texture->target);

    pg_pass_t* pass = (pg_pass_t*)PICO_GFX_MALLOC(sizeof(pg_pass_t));

    pass->handle = sg_make_pass(&(sg_pass_desc)
    {
        .color_attachments[0].image = texture->handle,
        .depth_stencil_attachment.image = texture->depth_handle
    });

    pass->texture = texture;

    return pass;
}

void pg_destroy_pass(pg_pass_t* pass)
{
    PICO_GFX_ASSERT(pass);
    sg_destroy_pass(pass->handle);
    PICO_GFX_FREE(pass);
}

void pg_begin_pass(pg_ctx_t* ctx, pg_pass_t* pass, bool clear)
{
    PICO_GFX_ASSERT(ctx);

    sg_pass_action pass_action;

    memset(&pass_action, 0, sizeof(sg_pass_action));

    if (clear)
    {
        sg_color color = ctx->state.clear_color;

        pass_action.colors[0] = (sg_color_attachment_action)
        {
            .load_action = SG_LOADACTION_CLEAR,
            .clear_value = color
        };
    }

    if (pass)
    {
        sg_begin_pass(pass->handle, &pass_action);
        ctx->pass = pass;
    }
    else
    {
        sg_begin_default_pass(&pass_action, ctx->window_width, ctx->window_height);
        ctx->pass = NULL;
    }
}

void pg_end_pass()
{
    sg_end_pass();
}

void pg_flush(pg_ctx_t* ctx)
{
    PICO_GFX_ASSERT(ctx);

    sg_commit();

    sg_destroy_buffer(ctx->buffer);

    ctx->buffer = sg_make_buffer(&(sg_buffer_desc)
    {
        .type  = SG_BUFFERTYPE_VERTEXBUFFER,
        .size  = PICO_GFX_BUFFER_SIZE * sizeof(pg_vertex_t),
        .usage = SG_USAGE_STREAM
    });

    sg_destroy_buffer(ctx->index_buffer);

    ctx->index_buffer = sg_make_buffer(&(sg_buffer_desc)
    {
        .type  = SG_BUFFERTYPE_INDEXBUFFER,
        .size  = PICO_GFX_BUFFER_SIZE * sizeof(uint32_t),
        .usage = SG_USAGE_STREAM
    });
}

void pg_push_state(pg_ctx_t* ctx)
{
    PICO_GFX_ASSERT(ctx);
    PICO_GFX_ASSERT(ctx->stack_size < PICO_GFX_STACK_MAX_SIZE);

    ctx->state_stack[ctx->stack_size] = ctx->state;
    ctx->stack_size++;
}

void pg_pop_state(pg_ctx_t* ctx)
{
    PICO_GFX_ASSERT(ctx);
    PICO_GFX_ASSERT(ctx->stack_size > 0);

    ctx->state = ctx->state_stack[ctx->stack_size - 1];
    ctx->stack_size--;
}

void pg_reset_state(pg_ctx_t* ctx)
{
    PICO_GFX_ASSERT(ctx);

    memset(&ctx->state, 0, sizeof(pg_state_t));

    pg_set_clear_color(ctx, 0.f, 0.f, 0.f, 1.f);
    pg_set_pipeline(ctx, ctx->default_pipeline);

    if (ctx->pass)
    {
        pg_texture_t* texture = ctx->pass->texture;
        pg_set_scissor(ctx, 0, 0, texture->width, texture->height);
        pg_set_viewport(ctx, 0, 0, texture->width, texture->height);
    }
    else
    {
        pg_set_scissor(ctx, 0, 0, ctx->window_width, ctx->window_height);
        pg_set_viewport(ctx, 0, 0, ctx->window_width, ctx->window_height);
    }
}

void pg_set_pipeline(pg_ctx_t* ctx, pg_pipeline_t* pipeline)
{
    PICO_GFX_ASSERT(ctx);
    PICO_GFX_ASSERT(pipeline);
    ctx->state.pipeline = pipeline;
}

pg_pipeline_t* pg_create_pipeline(pg_primitive_t primitive,
                                  bool target,
                                  bool indexed,
                                  pg_shader_t* shader,
                                  const pg_blend_mode_t* blend_mode)
{
    PICO_GFX_ASSERT(shader);

    sg_pipeline_desc desc;

    memset(&desc, 0, sizeof(sg_pipeline_desc));

    desc.layout.attrs[0] = (sg_vertex_attr_desc){ .format = SG_VERTEXFORMAT_FLOAT3, .offset = offsetof(pg_vertex_t, pos) },
    desc.layout.attrs[1] = (sg_vertex_attr_desc){ .format = SG_VERTEXFORMAT_FLOAT4, .offset = offsetof(pg_vertex_t, color) },
    desc.layout.attrs[2] = (sg_vertex_attr_desc){ .format = SG_VERTEXFORMAT_FLOAT2, .offset = offsetof(pg_vertex_t, uv) },

    desc.primitive_type = pg_map_primitive(primitive);

    if (blend_mode)
    {
        desc.colors[0].blend.enabled = true;
        desc.colors[0].blend.src_factor_rgb = pg_map_blend_factor(blend_mode->color_src);
        desc.colors[0].blend.dst_factor_rgb = pg_map_blend_factor(blend_mode->color_dst);
        desc.colors[0].blend.src_factor_alpha = pg_map_blend_factor(blend_mode->alpha_src);
        desc.colors[0].blend.dst_factor_alpha = pg_map_blend_factor(blend_mode->alpha_dst);
        desc.colors[0].blend.op_rgb = pg_map_blend_eq(blend_mode->color_eq);
        desc.colors[0].blend.op_alpha = pg_map_blend_eq(blend_mode->alpha_eq);
    }

    desc.colors[0].pixel_format = SG_PIXELFORMAT_RGBA8;

    if (indexed)
        desc.index_type = SG_INDEXTYPE_UINT32;
    else
        desc.index_type = SG_INDEXTYPE_NONE;

    if (target)
    {
        desc.depth.pixel_format = SG_PIXELFORMAT_DEPTH;
        desc.depth.write_enabled = true;
    }

    desc.shader = shader->handle;

    pg_pipeline_t* pipeline = (pg_pipeline_t*)PICO_GFX_MALLOC(sizeof(pg_pipeline_t));

    pipeline->handle = sg_make_pipeline(&desc);
    pipeline->indexed = indexed;
    pipeline->shader = shader;

    return pipeline;
}

void pg_set_clear_color(pg_ctx_t* ctx, float r, float g, float b, float a)
{
    ctx->state.clear_color = (sg_color){ r, g, b, a};
}

void pg_set_viewport(pg_ctx_t* ctx, int x, int y, int w, int h)
{
    ctx->state.viewport = (pg_rect_t){ x, y, w, h};
}

void pg_set_scissor(pg_ctx_t* ctx, int x, int y, int w, int h)
{
    ctx->state.scissor = (pg_rect_t){ x, y, w, h};
}

pg_shader_t* pg_create_shader_internal(pg_shader_internal_t internal)
{
    pg_shader_t* shader = (pg_shader_t*)PICO_GFX_MALLOC(sizeof(pg_shader_t));

    shader->internal = internal;

    PICO_GFX_LOG("Graphics backend: %d", sg_query_backend());

    shader->desc = internal.get_shader_desc(sg_query_backend());

    PICO_GFX_ASSERT(shader->desc);

    PICO_GFX_LOG("Shader attributes %s, %s, %s", shader->desc->attrs[0].name,
                                                 shader->desc->attrs[1].name,
                                                 shader->desc->attrs[2].name);

    shader->handle = sg_make_shader(shader->desc);
    shader->uniform_blocks = pg_hashtable_new(16, 32, sizeof(pg_uniform_block_t)); // TODO: constants

    shader->arena = pg_arena_new(1024);

    return shader;
}

void pg_destroy_shader(pg_shader_t* shader)
{
    PICO_GFX_ASSERT(shader);
    sg_destroy_shader(shader->handle);
    pg_hashtable_free(shader->uniform_blocks);
    pg_arena_free(shader->arena);
}

pg_shader_t* pg_get_default_shader(pg_ctx_t* ctx)
{
    PICO_GFX_ASSERT(ctx);
    return ctx->default_shader;
}

pg_pipeline_t* pg_get_default_pipeline(pg_ctx_t* ctx)
{
    PICO_GFX_ASSERT(ctx);
    return ctx->default_pipeline;
}

uint32_t pg_get_shader_id(pg_shader_t* shader)
{
    PICO_GFX_ASSERT(shader);
    return shader->handle.id;
}

void pg_register_uniform_block(pg_shader_t* shader, char* name, pg_stage_t stage, size_t size)
{
    PICO_GFX_ASSERT(shader);
    PICO_GFX_ASSERT(name);
    PICO_GFX_ASSERT(size > 0);

    pg_uniform_block_t block =
    {
        .stage = stage,
        .data  = pg_arena_alloc(shader->arena, size),
        .size  = size,
        .dirty = false
    };

    pg_str_copy(block.name, name, sizeof(block.name));

    pg_hashtable_put(shader->uniform_blocks, name, &block);
}

void pg_set_uniform_block(pg_shader_t* shader, char* name, void* data)
{
    PICO_GFX_ASSERT(shader);
    PICO_GFX_ASSERT(name);
    PICO_GFX_ASSERT(data);

    pg_uniform_block_t* block = pg_hashtable_get(shader->uniform_blocks, name);

    PICO_GFX_ASSERT(block);

    memcpy(block->data, data, block->size);
    block->dirty = true;
}

pg_texture_t* pg_create_texture(int width, int height,
                                uint8_t* data, size_t size,
                                int mipmaps, bool smooth, bool repeat)
{
    PICO_GFX_ASSERT(width > 0);
    PICO_GFX_ASSERT(height > 0);
    PICO_GFX_ASSERT(data);
    PICO_GFX_ASSERT(size > 0);
    PICO_GFX_ASSERT(mipmaps >= 0);

    pg_texture_t* texture = (pg_texture_t*)PICO_GFX_MALLOC(sizeof(pg_texture_t));

    sg_image_desc desc;

    memset(&desc, 0, sizeof(sg_image_desc));

    desc.width  = texture->width  = width;
    desc.height = texture->height = height;

    desc.num_mipmaps = mipmaps;

    desc.min_filter = (smooth) ? SG_FILTER_LINEAR : SG_FILTER_NEAREST;
    desc.mag_filter = (smooth) ? SG_FILTER_LINEAR : SG_FILTER_NEAREST;

    desc.wrap_u = (repeat) ? SG_WRAP_REPEAT : SG_WRAP_CLAMP_TO_EDGE;
    desc.wrap_v = (repeat) ? SG_WRAP_REPEAT : SG_WRAP_CLAMP_TO_EDGE;

    desc.data.subimage[0][0] = (sg_range){ .ptr = data, .size = size };

    texture->handle = sg_make_image(&desc);
    texture->target = false;

    return texture;
}

pg_texture_t* pg_create_render_texture(int width, int height,
                                       int mipmaps, bool smooth, bool repeat)
{
    PICO_GFX_ASSERT(width > 0);
    PICO_GFX_ASSERT(height > 0);
    PICO_GFX_ASSERT(mipmaps >= 0);

    pg_texture_t* texture = (pg_texture_t*)PICO_GFX_MALLOC(sizeof(pg_texture_t));

    sg_image_desc desc;

    memset(&desc, 0, sizeof(sg_image_desc));

    desc.render_target = true;
    desc.pixel_format = SG_PIXELFORMAT_RGBA8;

    desc.width  = texture->width  = width;
    desc.height = texture->height = height;

    desc.num_mipmaps = mipmaps;

    desc.min_filter = (smooth) ? SG_FILTER_LINEAR : SG_FILTER_NEAREST;
    desc.mag_filter = (smooth) ? SG_FILTER_LINEAR : SG_FILTER_NEAREST;

    desc.wrap_u = (repeat) ? SG_WRAP_REPEAT : SG_WRAP_CLAMP_TO_EDGE;
    desc.wrap_v = (repeat) ? SG_WRAP_REPEAT : SG_WRAP_CLAMP_TO_EDGE;

    texture->handle = sg_make_image(&desc);
    texture->target = true;

    desc.pixel_format = SG_PIXELFORMAT_DEPTH;
    texture->depth_handle = sg_make_image(&desc);

    return texture;
}

/*TODO:
void pg_update_texture(pg_texture_t* texture, uint8_t* data, size_t size)
{

}*/

uint32_t pg_get_texture_id(pg_texture_t* texture)
{
    PICO_GFX_ASSERT(texture);
    return texture->handle.id;
}

void pg_get_texture_size(const pg_texture_t* texture, int* width, int* height)
{
    PICO_GFX_ASSERT(texture);

    if (width)
        *width = texture->width;

    if (height)
        *height = texture->height;
}

static void pg_apply_uniforms(pg_shader_t* shader)
{
    PICO_GFX_ASSERT(shader);

    pg_hashtable_iterator_t iterator;
    pg_hashtable_init_iterator(shader->uniform_blocks, &iterator);

    char* key = NULL;
    void* value = NULL;

    while (pg_hashtable_iterator_next(&iterator, &key, &value))
    {
        pg_uniform_block_t* block = value;

        //if (block->dirty)
        //{
            sg_range range = { .ptr = block->data, .size = block->size };

            sg_shader_stage stage = pg_map_stage(block->stage);

            int slot = shader->internal.get_uniformblock_slot(stage, block->name);

            sg_apply_uniforms(stage, slot, &range);

            block->dirty = false;
        //}
    }
}

pg_vbuffer_t* pg_create_vbuffer(const pg_vertex_t* vertices, size_t count)
{
    PICO_GFX_ASSERT(vertices);
    PICO_GFX_ASSERT(count > 0);

    pg_vbuffer_t* buffer = (pg_vbuffer_t*)PICO_GFX_MALLOC(sizeof(pg_vbuffer_t));

    buffer->handle = sg_make_buffer(&(sg_buffer_desc)
    {
        .type  = SG_BUFFERTYPE_VERTEXBUFFER,
        .usage = SG_USAGE_IMMUTABLE,
        .data  = { .ptr = vertices, .size = count * sizeof(pg_vertex_t) }
    });

    buffer->count = count;

    return buffer;
}

void pg_destroy_vbuffer(pg_vbuffer_t* buffer)
{
    PICO_GFX_ASSERT(buffer);
    sg_destroy_buffer(buffer->handle);
    PICO_GFX_FREE(buffer);
}

static void pg_apply_view_state(pg_ctx_t* ctx)
{
    pg_rect_t* rect = &ctx->state.viewport;
    sg_apply_viewport(rect->x, rect->y, rect->width, rect->height, true);

    rect = &ctx->state.scissor;
    sg_apply_scissor_rect(rect->x, rect->y, rect->width, rect->height, true);
}

void pg_draw_vbuffer(pg_ctx_t* ctx,
                     pg_vbuffer_t* buffer,
                     size_t start, size_t count,
                     pg_texture_t* texture)
{
    PICO_GFX_ASSERT(ctx);
    PICO_GFX_ASSERT(buffer);
    PICO_GFX_ASSERT(!ctx->state.pipeline->indexed);

    sg_bindings bindings;

    memset(&bindings, 0, sizeof(sg_bindings));

    if (texture)
        bindings.fs_images[0] = texture->handle;

    bindings.vertex_buffers[0] = buffer->handle;

    pg_apply_view_state(ctx);

    pg_pipeline_t* pipeline = ctx->state.pipeline;

    sg_apply_pipeline(pipeline->handle);
    sg_apply_bindings(&bindings);
    pg_apply_uniforms(pipeline->shader);

    PICO_GFX_ASSERT(start + count <= buffer->count);

    sg_draw(start, count, 1);
}

void pg_draw_array(pg_ctx_t* ctx,
                   const pg_vertex_t* vertices, size_t count,
                   pg_texture_t* texture)
{
    PICO_GFX_ASSERT(ctx);
    PICO_GFX_ASSERT(vertices);
    PICO_GFX_ASSERT(count > 0);
    PICO_GFX_ASSERT(!ctx->state.pipeline->indexed);

    int offset = sg_append_buffer(ctx->buffer, &(sg_range) { .ptr = vertices, .size = count * sizeof(pg_vertex_t)});

    sg_bindings bindings;

    memset(&bindings, 0, sizeof(sg_bindings));

    if (texture)
        bindings.fs_images[0] = texture->handle;

    bindings.vertex_buffer_offsets[0] = offset;
    bindings.vertex_buffers[0] = ctx->buffer;

    pg_apply_view_state(ctx);

    pg_pipeline_t* pipeline = ctx->state.pipeline;

    sg_apply_pipeline(pipeline->handle);
    sg_apply_bindings(&bindings);
    pg_apply_uniforms(pipeline->shader);

    sg_draw(0, count, 1);
}

void pg_draw_indexed_array(pg_ctx_t* ctx,
                           const pg_vertex_t* vertices, size_t vertex_count,
                           const uint32_t* indices, size_t index_count,
                           pg_texture_t* texture)
{
    PICO_GFX_ASSERT(ctx);
    PICO_GFX_ASSERT(vertices);
    PICO_GFX_ASSERT(vertex_count > 0);
    PICO_GFX_ASSERT(indices);
    PICO_GFX_ASSERT(index_count > 0);
    PICO_GFX_ASSERT(ctx->state.pipeline->indexed);

    int vertex_offset = sg_append_buffer(ctx->buffer, &(sg_range)
    {
        .ptr = vertices, .size = vertex_count * sizeof(pg_vertex_t)
    });

    int index_offset = sg_append_buffer(ctx->index_buffer, &(sg_range)
    {
        .ptr = indices, .size = index_count * sizeof(uint32_t)
    });

    sg_bindings bindings;

    memset(&bindings, 0, sizeof(sg_bindings));

    if (texture)
        bindings.fs_images[0] = texture->handle;

    bindings.vertex_buffer_offsets[0] = vertex_offset;
    bindings.index_buffer_offset = index_offset;
    bindings.vertex_buffers[0] = ctx->buffer;
    bindings.index_buffer = ctx->index_buffer;

    pg_apply_view_state(ctx);

    pg_pipeline_t* pipeline = ctx->state.pipeline;

    sg_apply_pipeline(pipeline->handle);
    sg_apply_bindings(&bindings);
    pg_apply_uniforms(pipeline->shader);

    sg_draw(0, index_count, 1);
}

/*==============================================================================
 * GFX Static Functions
 *============================================================================*/

static sg_primitive_type pg_map_primitive(pg_primitive_t primitive)
{
    switch (primitive)
    {
        case PG_POINTS:         return SG_PRIMITIVETYPE_POINTS;
        case PG_LINES:          return SG_PRIMITIVETYPE_LINES;
        case PG_LINE_STRIP:     return SG_PRIMITIVETYPE_LINE_STRIP;
        case PG_TRIANGLES:      return SG_PRIMITIVETYPE_TRIANGLES;
        case PG_TRIANGLE_STRIP: return SG_PRIMITIVETYPE_TRIANGLE_STRIP;
        default: PICO_GFX_ASSERT(false);
    }
}

static sg_blend_factor pg_map_blend_factor(pg_blend_factor_t factor)
{
    switch (factor)
    {
        case PG_ZERO:                return SG_BLENDFACTOR_ZERO;
        case PG_ONE:                 return SG_BLENDFACTOR_ONE;
        case PG_SRC_COLOR:           return SG_BLENDFACTOR_SRC_COLOR;
        case PG_ONE_MINUS_SRC_COLOR: return SG_BLENDFACTOR_ONE_MINUS_SRC_COLOR;
        case PG_DST_COLOR:           return SG_BLENDFACTOR_DST_COLOR;
        case PG_ONE_MINUS_DST_COLOR: return SG_BLENDFACTOR_ZERO;
        case PG_SRC_ALPHA:           return SG_BLENDFACTOR_SRC_ALPHA;
        case PG_ONE_MINUS_SRC_ALPHA: return SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA;
        case PG_DST_ALPHA:           return SG_BLENDFACTOR_DST_ALPHA;
        case PG_ONE_MINUS_DST_ALPHA: return SG_BLENDFACTOR_ONE_MINUS_DST_ALPHA;
        default: PICO_GFX_ASSERT(false);
    }
}

static sg_blend_op pg_map_blend_eq(pg_blend_eq_t eq)
{
    switch (eq)
    {
        case PG_FUNC_ADD:              return SG_BLENDOP_ADD;
        case PG_FUNC_SUBTRACT:         return SG_BLENDOP_SUBTRACT;
        case PG_FUNC_REVERSE_SUBTRACT: return SG_BLENDOP_REVERSE_SUBTRACT;
        default: PICO_GFX_ASSERT(false);
    }
}

static sg_shader_stage pg_map_stage(pg_stage_t stage)
{
    switch (stage)
    {
        case PG_VS_STAGE: return SG_SHADERSTAGE_VS;
        case PG_FS_STAGE: return SG_SHADERSTAGE_FS;
        default: PICO_GFX_ASSERT(false);
    }
}

static void pg_log(const char* fmt, ...)
{
    PICO_GFX_ASSERT(fmt);

    va_list args;
    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
    printf("\n");
    fflush(stdout);
}

static void pg_log_sg(const char* tag,                // e.g. 'sg'
                      uint32_t log_level,             // 0=panic, 1=error, 2=warn, 3=info
                      uint32_t log_item_id,           // SG_LOGITEM_*
                      const char* message_or_null,    // a message string, may be nullptr in release mode
                      uint32_t line_nr,               // line number in sokol_gfx.h
                      const char* filename_or_null,   // source filename, may be nullptr in release mode
                      void* user_data)
{
    static const char* level[] =
    {
        "Panic",
        "Error",
        "Warn",
        "Info",
    };

    // FIXME: Handle non-debug case

    if (message_or_null && !filename_or_null)
    {
        PICO_GFX_LOG("Tag: %s, Level: %s, Message: %s", tag, level[log_level], message_or_null);
    }

    if (!message_or_null && filename_or_null)
    {
        PICO_GFX_LOG("Tag: %s, Level: %s, File: %s, Line: %d", tag, level[log_level], filename_or_null, line_nr);
    }

    if (message_or_null && filename_or_null)
    {
        PICO_GFX_LOG("Tag: %s, Level: %s, File: %s, Line: %d, Message: %s", tag, level[log_level], filename_or_null, line_nr, message_or_null);
    }
}

/*==============================================================================
 * Hashtable Data structures
 *============================================================================*/

typedef struct
{
    bool in_use;
    pg_hash_t hash;
    char* key;
    void* value;
} pg_hashtable_entry_t;

struct pg_hashtable_t
{
    size_t capacity;
    size_t size;

    pg_hashtable_entry_t* entries;

    size_t key_size;
    char* keys;

    size_t value_size;
    void* values;
};

/*==============================================================================
 * Hashtable Internal Declarations
 *============================================================================*/

static size_t pg_hashtable_compute_hash(const pg_hashtable_t* ht, const char* key);
static bool pg_hashtable_key_equal(pg_hashtable_t* ht, const char* key1, const char* key2);
static void pg_hashtable_copy_value(pg_hashtable_t* ht, pg_hashtable_entry_t* entry, const void* value);
static void pg_hashtable_swap_size(size_t* a, size_t* b);
static void pg_hashtable_swap_ptr(void** a, void** b);
static void pg_hashtable_swap(pg_hashtable_t* ht1, pg_hashtable_t* ht2);
static void pg_hashtable_rehash(pg_hashtable_t* ht);

/*==============================================================================
 * Hashtable Public Implementation
 *============================================================================*/

static pg_hashtable_t* pg_hashtable_new(size_t capacity, size_t key_size, size_t value_size)
{
    bool power_of_two = (0 == (capacity & (capacity - 1)));

    PICO_GFX_ASSERT(capacity > 2 && power_of_two);
    PICO_GFX_ASSERT(key_size > 0);
    PICO_GFX_ASSERT(value_size > 0);

    if (capacity <= 2 || !power_of_two)
        return NULL;

    if (0 == key_size || 0 == value_size)
        return NULL;

    pg_hashtable_t* ht = PICO_GFX_MALLOC(sizeof(pg_hashtable_t));

    if (!ht)
        return NULL;

    ht->capacity = capacity;
    ht->size = 0;
    ht->key_size = key_size;
    ht->value_size = value_size;

    ht->entries = PICO_GFX_MALLOC(capacity * sizeof(pg_hashtable_entry_t));

    if (!ht->entries)
    {
        PICO_GFX_FREE(ht);
        return NULL;
    }

    ht->keys = PICO_GFX_MALLOC(capacity * key_size);

    if (!ht->keys)
    {
        PICO_GFX_FREE(ht->entries);
        PICO_GFX_FREE(ht);

        return NULL;
    }

    if (value_size > 0)
    {
        ht->values = PICO_GFX_MALLOC(capacity * value_size);

        if (!ht->values)
        {
            PICO_GFX_FREE(ht->entries);
            PICO_GFX_FREE(ht->keys);
            PICO_GFX_FREE(ht);
            return NULL;
        }
    }
    else
    {
        ht->values = NULL;
    }

    for (size_t i = 0; i < capacity; i++)
    {
        pg_hashtable_entry_t* entry = &ht->entries[i];
        entry->in_use = false;
        entry->hash = 0;
        entry->key = (char*)ht->keys + i * key_size;

        if (value_size > 0)
            entry->value = (char*)ht->values + i * value_size;
        else
            entry->value = NULL;
    }

    return ht;
}

static void pg_hashtable_free(pg_hashtable_t* ht)
{
    PICO_GFX_ASSERT(NULL != ht);

    PICO_GFX_FREE(ht->entries);
    PICO_GFX_FREE(ht->keys);

    if (ht->value_size > 0)
        PICO_GFX_FREE(ht->values);

    PICO_GFX_FREE(ht);
}

static size_t pg_hashtable_capacity(const pg_hashtable_t* ht)
{
    PICO_GFX_ASSERT(NULL != ht);
    return ht->capacity;
}

static size_t pg_hashtable_size(const pg_hashtable_t* ht)
{
    PICO_GFX_ASSERT(NULL != ht);
    return ht->size;
}

static bool pg_hashtable_is_empty(const pg_hashtable_t* ht)
{
    PICO_GFX_ASSERT(NULL != ht);
    return 0 == pg_hashtable_size(ht);
}

static void pg_hashtable_init_iterator(pg_hashtable_t* ht, pg_hashtable_iterator_t* iterator)
{
    PICO_GFX_ASSERT(NULL != ht);
    iterator->ht = ht;
    iterator->index = 0;
    iterator->count = 0;
}

static bool pg_hashtable_iterator_next(pg_hashtable_iterator_t* iterator, char** key, void** value)
{
    PICO_GFX_ASSERT(NULL != iterator);

    pg_hashtable_t* ht = iterator->ht;

    if (iterator->count >= ht->capacity)
        return false;

    while (iterator->index < ht->capacity)
    {
        pg_hashtable_entry_t* entry = &ht->entries[iterator->index];

        if (entry->in_use)
        {
            if (key)
                *key = entry->key;

            if (value)
                *value = entry->value;

            iterator->count++;
            iterator->index++;

            return true;
        }

        iterator->index++;
    }

    return false;
}

static void pg_hashtable_put(pg_hashtable_t* ht, const char* key, const void* value)
{
    PICO_GFX_ASSERT(NULL != ht);

    if (ht->size == ht->capacity)
    {
        pg_hashtable_rehash(ht);
        PICO_GFX_ASSERT(ht->capacity > 0);
    }

    pg_hash_t hash = pg_hashtable_compute_hash(ht, key);
    size_t start_index = hash % ht->capacity;
    size_t index = start_index;

    do
    {
        pg_hashtable_entry_t* entry = &ht->entries[index];

        if (entry->in_use && entry->hash == hash && pg_hashtable_key_equal(ht, key, entry->key))
        {
            pg_hashtable_copy_value(ht, entry, value);
            break;
        }

        if (!entry->in_use)
        {
            entry->in_use = true;
            entry->hash = hash;

            memcpy(entry->key, key, ht->key_size);
            pg_hashtable_copy_value(ht, entry, value);

            ht->size++;

            break;
        }

        index = (index + 1) % ht->capacity;

    } while (index != start_index);

    start_index = index;
    index = (index + 1) % ht->capacity;

    while (index != start_index)
    {
        pg_hashtable_entry_t* entry = &ht->entries[index];

        if (entry->in_use &&
            entry->hash == hash &&
            pg_hashtable_key_equal(ht, key, entry->key))
        {
            entry->in_use = false;
            ht->size--;
            return;
        }

        index = (index + 1) % ht->capacity;
    }
}

static void* pg_hashtable_get(pg_hashtable_t* ht, const char* key)
{
    PICO_GFX_ASSERT(NULL != ht);

    pg_hash_t hash = pg_hashtable_compute_hash(ht, key);
    size_t start_index = hash % ht->capacity;
    size_t index = start_index;

    do
    {
        pg_hashtable_entry_t* entry = &ht->entries[index];

        if (entry->in_use &&
            entry->hash == hash &&
            pg_hashtable_key_equal(ht, key, entry->key))
        {
            return entry->value;
        }

        index = (index + 1) % ht->capacity;

    } while (index != start_index);

    return NULL;
}

static bool pg_hashtable_exists(pg_hashtable_t* ht, const char* key)
{
    PICO_GFX_ASSERT(NULL != ht);
    return NULL != pg_hashtable_get(ht, key);
}

static void pg_hashtable_remove(pg_hashtable_t* ht, const char* key)
{
    PICO_GFX_ASSERT(NULL != ht);

    pg_hash_t hash = pg_hashtable_compute_hash(ht, key);
    size_t start_index = hash % ht->capacity;
    size_t index = start_index;

    do
    {
        pg_hashtable_entry_t* entry = &ht->entries[index];

        if (entry->in_use && entry->hash == hash && pg_hashtable_key_equal(ht, key, entry->key))
        {
            ht->size--;
            entry->in_use = false;
            return;
        }

        index = (index + 1) % ht->capacity;

    } while (index != start_index);
}

/*==============================================================================
 * Hashtable Internal API
 *============================================================================*/

static bool pg_hashtable_key_equal(pg_hashtable_t* ht, const char* key1, const char* key2)
{
    return 0 == strncmp(key1, key2, ht->key_size);
}

static void pg_hashtable_copy_value(pg_hashtable_t* ht, pg_hashtable_entry_t* entry, const void* value)
{
    memcpy(entry->value, value, ht->value_size);
}

static void pg_hashtable_swap_size(size_t* a, size_t* b)
{
    size_t tmp = *a;
    *a = *b;
    *b = tmp;
}

static void pg_hashtable_swap_ptr(void** a, void** b)
{
    void* tmp = *a;
    *a = *b;
    *b = tmp;
}

static void pg_hashtable_swap(pg_hashtable_t* ht1, pg_hashtable_t* ht2)
{
    pg_hashtable_swap_size(&ht1->capacity, &ht2->capacity);
    pg_hashtable_swap_size(&ht1->size, &ht2->size);

    pg_hashtable_swap_ptr((void**)&ht1->entries, (void**)&ht2->entries);

    pg_hashtable_swap_size(&ht1->key_size, &ht2->key_size);
    pg_hashtable_swap_ptr((void**)&ht1->keys, (void**)&ht2->keys);

    pg_hashtable_swap_size(&ht1->value_size, &ht2->value_size);
    pg_hashtable_swap_ptr(&ht1->values, &ht2->values);
}

static void pg_hashtable_rehash(pg_hashtable_t* ht)
{
    pg_hashtable_t* new_ht = pg_hashtable_new(ht->capacity * 2, ht->key_size, ht->size);

    pg_hashtable_iterator_t iterator;
    pg_hashtable_init_iterator(ht, &iterator);

    char* key;
    void* value;

    while (pg_hashtable_iterator_next(&iterator, &key, &value))
    {
        pg_hashtable_put(new_ht, key, value);
    }

    pg_hashtable_swap(ht, new_ht);

    pg_hashtable_free(new_ht);
}

/*==============================================================================
 * Hash Functions
 *============================================================================*/

static size_t pg_hashtable_compute_hash(const pg_hashtable_t* ht, const char* key)
{

#ifdef PICO_GFX_32BIT
    static const uint32_t offset_basis = 0x811C9DC5;
    static const uint32_t prime = 0x1000193;
#else
    static const uint64_t offset_basis = 0xCBF29CE484222325;
    static const uint64_t prime = 0x100000001B3;
#endif

    const char* data = key;

    pg_hash_t hash = offset_basis;

    for (size_t i = 0; i < ht->key_size; i++) {
        hash ^= (pg_hash_t)data[i];
        hash *= prime;
    }

    return hash;
}

/*==============================================================================
 * Arena allocator
 *============================================================================*/

struct pg_arena_t
{
    size_t capacity;
    size_t size;
    void*  block;
};

static pg_arena_t* pg_arena_new(size_t size)
{
    PICO_GFX_ASSERT(size > 0);

    pg_arena_t* arena = PICO_GFX_MALLOC(sizeof(pg_arena_t));

    memset(arena, 0, sizeof(pg_arena_t));

    arena->capacity = size * 2;
    arena->block = PICO_GFX_MALLOC(arena->capacity);
    arena->size = size;

    return arena;
}

static void* pg_arena_alloc(pg_arena_t* arena, size_t size)
{
    if (arena->size + size > arena->capacity)
    {
        while (arena->size + size >= arena->capacity)
        {
            arena->capacity *= 2;
        }

        arena->block = PICO_GFX_REALLOC(arena->block, arena->capacity);
    }

    void* mem = (char*)arena->block + arena->size;

    arena->size += size;

    return mem;
}

static void pg_arena_free(pg_arena_t* arena)
{
    PICO_GFX_FREE(arena->block);
    PICO_GFX_FREE(arena);
}

/*==============================================================================
 * Default Shader Internals
 *============================================================================*/

#if defined(SOKOL_GLCORE33)
/*
    #version 330

    uniform vec4 pg_vs[4];
    layout(location = 0) in vec3 a_pos;
    out vec4 color;
    layout(location = 1) in vec4 a_color;
    out vec2 uv;
    layout(location = 2) in vec2 a_uv;

    void main()
    {
        gl_Position = mat4(pg_vs[0], pg_vs[1], pg_vs[2], pg_vs[3]) * vec4(a_pos, 1.0);
        color = a_color;
        uv = a_uv;
        gl_Position.y = -gl_Position.y;
    }

*/
static const char vs_source_glsl330[349] = {
    0x23,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,0x33,0x33,0x30,0x0a,0x0a,0x75,0x6e,
    0x69,0x66,0x6f,0x72,0x6d,0x20,0x76,0x65,0x63,0x34,0x20,0x70,0x67,0x5f,0x76,0x73,
    0x5b,0x34,0x5d,0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,
    0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x30,0x29,0x20,0x69,0x6e,0x20,0x76,0x65,0x63,
    0x33,0x20,0x61,0x5f,0x70,0x6f,0x73,0x3b,0x0a,0x6f,0x75,0x74,0x20,0x76,0x65,0x63,
    0x34,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,
    0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x31,0x29,0x20,0x69,0x6e,
    0x20,0x76,0x65,0x63,0x34,0x20,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x6f,
    0x75,0x74,0x20,0x76,0x65,0x63,0x32,0x20,0x75,0x76,0x3b,0x0a,0x6c,0x61,0x79,0x6f,
    0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x32,0x29,
    0x20,0x69,0x6e,0x20,0x76,0x65,0x63,0x32,0x20,0x61,0x5f,0x75,0x76,0x3b,0x0a,0x0a,
    0x76,0x6f,0x69,0x64,0x20,0x6d,0x61,0x69,0x6e,0x28,0x29,0x0a,0x7b,0x0a,0x20,0x20,
    0x20,0x20,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,
    0x6d,0x61,0x74,0x34,0x28,0x70,0x67,0x5f,0x76,0x73,0x5b,0x30,0x5d,0x2c,0x20,0x70,
    0x67,0x5f,0x76,0x73,0x5b,0x31,0x5d,0x2c,0x20,0x70,0x67,0x5f,0x76,0x73,0x5b,0x32,
    0x5d,0x2c,0x20,0x70,0x67,0x5f,0x76,0x73,0x5b,0x33,0x5d,0x29,0x20,0x2a,0x20,0x76,
    0x65,0x63,0x34,0x28,0x61,0x5f,0x70,0x6f,0x73,0x2c,0x20,0x31,0x2e,0x30,0x29,0x3b,
    0x0a,0x20,0x20,0x20,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,0x61,0x5f,0x63,
    0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x20,0x20,0x20,0x20,0x75,0x76,0x20,0x3d,0x20,0x61,
    0x5f,0x75,0x76,0x3b,0x0a,0x20,0x20,0x20,0x20,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,
    0x74,0x69,0x6f,0x6e,0x2e,0x79,0x20,0x3d,0x20,0x2d,0x67,0x6c,0x5f,0x50,0x6f,0x73,
    0x69,0x74,0x69,0x6f,0x6e,0x2e,0x79,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
/*
    #version 330

    uniform sampler2D u_tex;

    layout(location = 0) out vec4 frag_color;
    in vec2 uv;
    in vec4 color;

    void main()
    {
        frag_color = texture(u_tex, uv) * color;
    }

*/
static const char fs_source_glsl330[173] = {
    0x23,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,0x33,0x33,0x30,0x0a,0x0a,0x75,0x6e,
    0x69,0x66,0x6f,0x72,0x6d,0x20,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,0x32,0x44,0x20,
    0x75,0x5f,0x74,0x65,0x78,0x3b,0x0a,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,
    0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x30,0x29,0x20,0x6f,0x75,0x74,
    0x20,0x76,0x65,0x63,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,
    0x3b,0x0a,0x69,0x6e,0x20,0x76,0x65,0x63,0x32,0x20,0x75,0x76,0x3b,0x0a,0x69,0x6e,
    0x20,0x76,0x65,0x63,0x34,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x0a,0x76,0x6f,
    0x69,0x64,0x20,0x6d,0x61,0x69,0x6e,0x28,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,
    0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,0x74,0x65,0x78,
    0x74,0x75,0x72,0x65,0x28,0x75,0x5f,0x74,0x65,0x78,0x2c,0x20,0x75,0x76,0x29,0x20,
    0x2a,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
#endif /* SOKOL_GLCORE33 */
#if defined(SOKOL_GLES3)
/*
    #version 300 es

    uniform vec4 pg_vs[4];
    layout(location = 0) in vec3 a_pos;
    out vec4 color;
    layout(location = 1) in vec4 a_color;
    out vec2 uv;
    layout(location = 2) in vec2 a_uv;

    void main()
    {
        gl_Position = mat4(pg_vs[0], pg_vs[1], pg_vs[2], pg_vs[3]) * vec4(a_pos, 1.0);
        color = a_color;
        uv = a_uv;
        gl_Position.y = -gl_Position.y;
    }

*/
static const char vs_source_glsl300es[352] = {
    0x23,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,0x33,0x30,0x30,0x20,0x65,0x73,0x0a,
    0x0a,0x75,0x6e,0x69,0x66,0x6f,0x72,0x6d,0x20,0x76,0x65,0x63,0x34,0x20,0x70,0x67,
    0x5f,0x76,0x73,0x5b,0x34,0x5d,0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,
    0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x30,0x29,0x20,0x69,0x6e,0x20,
    0x76,0x65,0x63,0x33,0x20,0x61,0x5f,0x70,0x6f,0x73,0x3b,0x0a,0x6f,0x75,0x74,0x20,
    0x76,0x65,0x63,0x34,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x6c,0x61,0x79,0x6f,
    0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x31,0x29,
    0x20,0x69,0x6e,0x20,0x76,0x65,0x63,0x34,0x20,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,
    0x3b,0x0a,0x6f,0x75,0x74,0x20,0x76,0x65,0x63,0x32,0x20,0x75,0x76,0x3b,0x0a,0x6c,
    0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,
    0x20,0x32,0x29,0x20,0x69,0x6e,0x20,0x76,0x65,0x63,0x32,0x20,0x61,0x5f,0x75,0x76,
    0x3b,0x0a,0x0a,0x76,0x6f,0x69,0x64,0x20,0x6d,0x61,0x69,0x6e,0x28,0x29,0x0a,0x7b,
    0x0a,0x20,0x20,0x20,0x20,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,
    0x20,0x3d,0x20,0x6d,0x61,0x74,0x34,0x28,0x70,0x67,0x5f,0x76,0x73,0x5b,0x30,0x5d,
    0x2c,0x20,0x70,0x67,0x5f,0x76,0x73,0x5b,0x31,0x5d,0x2c,0x20,0x70,0x67,0x5f,0x76,
    0x73,0x5b,0x32,0x5d,0x2c,0x20,0x70,0x67,0x5f,0x76,0x73,0x5b,0x33,0x5d,0x29,0x20,
    0x2a,0x20,0x76,0x65,0x63,0x34,0x28,0x61,0x5f,0x70,0x6f,0x73,0x2c,0x20,0x31,0x2e,
    0x30,0x29,0x3b,0x0a,0x20,0x20,0x20,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,
    0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x20,0x20,0x20,0x20,0x75,0x76,0x20,
    0x3d,0x20,0x61,0x5f,0x75,0x76,0x3b,0x0a,0x20,0x20,0x20,0x20,0x67,0x6c,0x5f,0x50,
    0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x2e,0x79,0x20,0x3d,0x20,0x2d,0x67,0x6c,0x5f,
    0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x2e,0x79,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,

};
/*
    #version 300 es
    precision mediump float;
    precision highp int;

    uniform highp sampler2D u_tex;

    layout(location = 0) out highp vec4 frag_color;
    in highp vec2 uv;
    in highp vec4 color;

    void main()
    {
        frag_color = texture(u_tex, uv) * color;
    }

*/
static const char fs_source_glsl300es[246] = {
    0x23,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,0x33,0x30,0x30,0x20,0x65,0x73,0x0a,
    0x70,0x72,0x65,0x63,0x69,0x73,0x69,0x6f,0x6e,0x20,0x6d,0x65,0x64,0x69,0x75,0x6d,
    0x70,0x20,0x66,0x6c,0x6f,0x61,0x74,0x3b,0x0a,0x70,0x72,0x65,0x63,0x69,0x73,0x69,
    0x6f,0x6e,0x20,0x68,0x69,0x67,0x68,0x70,0x20,0x69,0x6e,0x74,0x3b,0x0a,0x0a,0x75,
    0x6e,0x69,0x66,0x6f,0x72,0x6d,0x20,0x68,0x69,0x67,0x68,0x70,0x20,0x73,0x61,0x6d,
    0x70,0x6c,0x65,0x72,0x32,0x44,0x20,0x75,0x5f,0x74,0x65,0x78,0x3b,0x0a,0x0a,0x6c,
    0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,
    0x20,0x30,0x29,0x20,0x6f,0x75,0x74,0x20,0x68,0x69,0x67,0x68,0x70,0x20,0x76,0x65,
    0x63,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x69,
    0x6e,0x20,0x68,0x69,0x67,0x68,0x70,0x20,0x76,0x65,0x63,0x32,0x20,0x75,0x76,0x3b,
    0x0a,0x69,0x6e,0x20,0x68,0x69,0x67,0x68,0x70,0x20,0x76,0x65,0x63,0x34,0x20,0x63,
    0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x0a,0x76,0x6f,0x69,0x64,0x20,0x6d,0x61,0x69,0x6e,
    0x28,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,
    0x6c,0x6f,0x72,0x20,0x3d,0x20,0x74,0x65,0x78,0x74,0x75,0x72,0x65,0x28,0x75,0x5f,
    0x74,0x65,0x78,0x2c,0x20,0x75,0x76,0x29,0x20,0x2a,0x20,0x63,0x6f,0x6c,0x6f,0x72,
    0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
#endif /* SOKOL_GLES3 */
#if defined(SOKOL_D3D11)
/*
    cbuffer pg_vs : register(b0)
    {
        row_major float4x4 _21_u_proj : packoffset(c0);
    };


    static float4 gl_Position;
    static float3 a_pos;
    static float4 color;
    static float4 a_color;
    static float2 uv;
    static float2 a_uv;

    struct SPIRV_Cross_Input
    {
        float3 a_pos : TEXCOORD0;
        float4 a_color : TEXCOORD1;
        float2 a_uv : TEXCOORD2;
    };

    struct SPIRV_Cross_Output
    {
        float4 color : TEXCOORD0;
        float2 uv : TEXCOORD1;
        float4 gl_Position : SV_Position;
    };

    void vert_main()
    {
        gl_Position = mul(float4(a_pos, 1.0f), _21_u_proj);
        color = a_color;
        uv = a_uv;
    }

    SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
    {
        a_pos = stage_input.a_pos;
        a_color = stage_input.a_color;
        a_uv = stage_input.a_uv;
        vert_main();
        SPIRV_Cross_Output stage_output;
        stage_output.gl_Position = gl_Position;
        stage_output.color = color;
        stage_output.uv = uv;
        return stage_output;
    }
*/
static const char vs_source_hlsl5[918] = {
    0x63,0x62,0x75,0x66,0x66,0x65,0x72,0x20,0x70,0x67,0x5f,0x76,0x73,0x20,0x3a,0x20,
    0x72,0x65,0x67,0x69,0x73,0x74,0x65,0x72,0x28,0x62,0x30,0x29,0x0a,0x7b,0x0a,0x20,
    0x20,0x20,0x20,0x72,0x6f,0x77,0x5f,0x6d,0x61,0x6a,0x6f,0x72,0x20,0x66,0x6c,0x6f,
    0x61,0x74,0x34,0x78,0x34,0x20,0x5f,0x32,0x31,0x5f,0x75,0x5f,0x70,0x72,0x6f,0x6a,
    0x20,0x3a,0x20,0x70,0x61,0x63,0x6b,0x6f,0x66,0x66,0x73,0x65,0x74,0x28,0x63,0x30,
    0x29,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x0a,0x73,0x74,0x61,0x74,0x69,0x63,0x20,0x66,
    0x6c,0x6f,0x61,0x74,0x34,0x20,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,
    0x6e,0x3b,0x0a,0x73,0x74,0x61,0x74,0x69,0x63,0x20,0x66,0x6c,0x6f,0x61,0x74,0x33,
    0x20,0x61,0x5f,0x70,0x6f,0x73,0x3b,0x0a,0x73,0x74,0x61,0x74,0x69,0x63,0x20,0x66,
    0x6c,0x6f,0x61,0x74,0x34,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x73,0x74,0x61,
    0x74,0x69,0x63,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x61,0x5f,0x63,0x6f,0x6c,
    0x6f,0x72,0x3b,0x0a,0x73,0x74,0x61,0x74,0x69,0x63,0x20,0x66,0x6c,0x6f,0x61,0x74,
    0x32,0x20,0x75,0x76,0x3b,0x0a,0x73,0x74,0x61,0x74,0x69,0x63,0x20,0x66,0x6c,0x6f,
    0x61,0x74,0x32,0x20,0x61,0x5f,0x75,0x76,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,
    0x74,0x20,0x53,0x50,0x49,0x52,0x56,0x5f,0x43,0x72,0x6f,0x73,0x73,0x5f,0x49,0x6e,
    0x70,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x33,
    0x20,0x61,0x5f,0x70,0x6f,0x73,0x20,0x3a,0x20,0x54,0x45,0x58,0x43,0x4f,0x4f,0x52,
    0x44,0x30,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x61,
    0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3a,0x20,0x54,0x45,0x58,0x43,0x4f,0x4f,0x52,
    0x44,0x31,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x61,
    0x5f,0x75,0x76,0x20,0x3a,0x20,0x54,0x45,0x58,0x43,0x4f,0x4f,0x52,0x44,0x32,0x3b,
    0x0a,0x7d,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x53,0x50,0x49,0x52,
    0x56,0x5f,0x43,0x72,0x6f,0x73,0x73,0x5f,0x4f,0x75,0x74,0x70,0x75,0x74,0x0a,0x7b,
    0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x63,0x6f,0x6c,0x6f,
    0x72,0x20,0x3a,0x20,0x54,0x45,0x58,0x43,0x4f,0x4f,0x52,0x44,0x30,0x3b,0x0a,0x20,
    0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x75,0x76,0x20,0x3a,0x20,0x54,
    0x45,0x58,0x43,0x4f,0x4f,0x52,0x44,0x31,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,
    0x6f,0x61,0x74,0x34,0x20,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,
    0x20,0x3a,0x20,0x53,0x56,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x3b,0x0a,
    0x7d,0x3b,0x0a,0x0a,0x76,0x6f,0x69,0x64,0x20,0x76,0x65,0x72,0x74,0x5f,0x6d,0x61,
    0x69,0x6e,0x28,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x67,0x6c,0x5f,0x50,0x6f,
    0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x6d,0x75,0x6c,0x28,0x66,0x6c,0x6f,
    0x61,0x74,0x34,0x28,0x61,0x5f,0x70,0x6f,0x73,0x2c,0x20,0x31,0x2e,0x30,0x66,0x29,
    0x2c,0x20,0x5f,0x32,0x31,0x5f,0x75,0x5f,0x70,0x72,0x6f,0x6a,0x29,0x3b,0x0a,0x20,
    0x20,0x20,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,0x61,0x5f,0x63,0x6f,0x6c,
    0x6f,0x72,0x3b,0x0a,0x20,0x20,0x20,0x20,0x75,0x76,0x20,0x3d,0x20,0x61,0x5f,0x75,
    0x76,0x3b,0x0a,0x7d,0x0a,0x0a,0x53,0x50,0x49,0x52,0x56,0x5f,0x43,0x72,0x6f,0x73,
    0x73,0x5f,0x4f,0x75,0x74,0x70,0x75,0x74,0x20,0x6d,0x61,0x69,0x6e,0x28,0x53,0x50,
    0x49,0x52,0x56,0x5f,0x43,0x72,0x6f,0x73,0x73,0x5f,0x49,0x6e,0x70,0x75,0x74,0x20,
    0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x70,0x75,0x74,0x29,0x0a,0x7b,0x0a,0x20,
    0x20,0x20,0x20,0x61,0x5f,0x70,0x6f,0x73,0x20,0x3d,0x20,0x73,0x74,0x61,0x67,0x65,
    0x5f,0x69,0x6e,0x70,0x75,0x74,0x2e,0x61,0x5f,0x70,0x6f,0x73,0x3b,0x0a,0x20,0x20,
    0x20,0x20,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,0x73,0x74,0x61,0x67,
    0x65,0x5f,0x69,0x6e,0x70,0x75,0x74,0x2e,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,
    0x0a,0x20,0x20,0x20,0x20,0x61,0x5f,0x75,0x76,0x20,0x3d,0x20,0x73,0x74,0x61,0x67,
    0x65,0x5f,0x69,0x6e,0x70,0x75,0x74,0x2e,0x61,0x5f,0x75,0x76,0x3b,0x0a,0x20,0x20,
    0x20,0x20,0x76,0x65,0x72,0x74,0x5f,0x6d,0x61,0x69,0x6e,0x28,0x29,0x3b,0x0a,0x20,
    0x20,0x20,0x20,0x53,0x50,0x49,0x52,0x56,0x5f,0x43,0x72,0x6f,0x73,0x73,0x5f,0x4f,
    0x75,0x74,0x70,0x75,0x74,0x20,0x73,0x74,0x61,0x67,0x65,0x5f,0x6f,0x75,0x74,0x70,
    0x75,0x74,0x3b,0x0a,0x20,0x20,0x20,0x20,0x73,0x74,0x61,0x67,0x65,0x5f,0x6f,0x75,
    0x74,0x70,0x75,0x74,0x2e,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,
    0x20,0x3d,0x20,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x3b,0x0a,
    0x20,0x20,0x20,0x20,0x73,0x74,0x61,0x67,0x65,0x5f,0x6f,0x75,0x74,0x70,0x75,0x74,
    0x2e,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,
    0x20,0x20,0x20,0x20,0x73,0x74,0x61,0x67,0x65,0x5f,0x6f,0x75,0x74,0x70,0x75,0x74,
    0x2e,0x75,0x76,0x20,0x3d,0x20,0x75,0x76,0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,
    0x74,0x75,0x72,0x6e,0x20,0x73,0x74,0x61,0x67,0x65,0x5f,0x6f,0x75,0x74,0x70,0x75,
    0x74,0x3b,0x0a,0x7d,0x0a,0x00,
};
/*
    Texture2D<float4> u_tex : register(t0);
    SamplerState _u_tex_sampler : register(s0);

    static float4 frag_color;
    static float2 uv;
    static float4 color;

    struct SPIRV_Cross_Input
    {
        float4 color : TEXCOORD0;
        float2 uv : TEXCOORD1;
    };

    struct SPIRV_Cross_Output
    {
        float4 frag_color : SV_Target0;
    };

    void frag_main()
    {
        frag_color = u_tex.Sample(_u_tex_sampler, uv) * color;
    }

    SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
    {
        uv = stage_input.uv;
        color = stage_input.color;
        frag_main();
        SPIRV_Cross_Output stage_output;
        stage_output.frag_color = frag_color;
        return stage_output;
    }
*/
static const char fs_source_hlsl5[625] = {
    0x54,0x65,0x78,0x74,0x75,0x72,0x65,0x32,0x44,0x3c,0x66,0x6c,0x6f,0x61,0x74,0x34,
    0x3e,0x20,0x75,0x5f,0x74,0x65,0x78,0x20,0x3a,0x20,0x72,0x65,0x67,0x69,0x73,0x74,
    0x65,0x72,0x28,0x74,0x30,0x29,0x3b,0x0a,0x53,0x61,0x6d,0x70,0x6c,0x65,0x72,0x53,
    0x74,0x61,0x74,0x65,0x20,0x5f,0x75,0x5f,0x74,0x65,0x78,0x5f,0x73,0x61,0x6d,0x70,
    0x6c,0x65,0x72,0x20,0x3a,0x20,0x72,0x65,0x67,0x69,0x73,0x74,0x65,0x72,0x28,0x73,
    0x30,0x29,0x3b,0x0a,0x0a,0x73,0x74,0x61,0x74,0x69,0x63,0x20,0x66,0x6c,0x6f,0x61,
    0x74,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x73,
    0x74,0x61,0x74,0x69,0x63,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x75,0x76,0x3b,
    0x0a,0x73,0x74,0x61,0x74,0x69,0x63,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x63,
    0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x53,0x50,
    0x49,0x52,0x56,0x5f,0x43,0x72,0x6f,0x73,0x73,0x5f,0x49,0x6e,0x70,0x75,0x74,0x0a,
    0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x63,0x6f,0x6c,
    0x6f,0x72,0x20,0x3a,0x20,0x54,0x45,0x58,0x43,0x4f,0x4f,0x52,0x44,0x30,0x3b,0x0a,
    0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x75,0x76,0x20,0x3a,0x20,
    0x54,0x45,0x58,0x43,0x4f,0x4f,0x52,0x44,0x31,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x73,
    0x74,0x72,0x75,0x63,0x74,0x20,0x53,0x50,0x49,0x52,0x56,0x5f,0x43,0x72,0x6f,0x73,
    0x73,0x5f,0x4f,0x75,0x74,0x70,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,
    0x6c,0x6f,0x61,0x74,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,
    0x20,0x3a,0x20,0x53,0x56,0x5f,0x54,0x61,0x72,0x67,0x65,0x74,0x30,0x3b,0x0a,0x7d,
    0x3b,0x0a,0x0a,0x76,0x6f,0x69,0x64,0x20,0x66,0x72,0x61,0x67,0x5f,0x6d,0x61,0x69,
    0x6e,0x28,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,
    0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,0x75,0x5f,0x74,0x65,0x78,0x2e,0x53,0x61,0x6d,
    0x70,0x6c,0x65,0x28,0x5f,0x75,0x5f,0x74,0x65,0x78,0x5f,0x73,0x61,0x6d,0x70,0x6c,
    0x65,0x72,0x2c,0x20,0x75,0x76,0x29,0x20,0x2a,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x3b,
    0x0a,0x7d,0x0a,0x0a,0x53,0x50,0x49,0x52,0x56,0x5f,0x43,0x72,0x6f,0x73,0x73,0x5f,
    0x4f,0x75,0x74,0x70,0x75,0x74,0x20,0x6d,0x61,0x69,0x6e,0x28,0x53,0x50,0x49,0x52,
    0x56,0x5f,0x43,0x72,0x6f,0x73,0x73,0x5f,0x49,0x6e,0x70,0x75,0x74,0x20,0x73,0x74,
    0x61,0x67,0x65,0x5f,0x69,0x6e,0x70,0x75,0x74,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,
    0x20,0x75,0x76,0x20,0x3d,0x20,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x70,0x75,
    0x74,0x2e,0x75,0x76,0x3b,0x0a,0x20,0x20,0x20,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x20,
    0x3d,0x20,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x70,0x75,0x74,0x2e,0x63,0x6f,
    0x6c,0x6f,0x72,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x72,0x61,0x67,0x5f,0x6d,0x61,
    0x69,0x6e,0x28,0x29,0x3b,0x0a,0x20,0x20,0x20,0x20,0x53,0x50,0x49,0x52,0x56,0x5f,
    0x43,0x72,0x6f,0x73,0x73,0x5f,0x4f,0x75,0x74,0x70,0x75,0x74,0x20,0x73,0x74,0x61,
    0x67,0x65,0x5f,0x6f,0x75,0x74,0x70,0x75,0x74,0x3b,0x0a,0x20,0x20,0x20,0x20,0x73,
    0x74,0x61,0x67,0x65,0x5f,0x6f,0x75,0x74,0x70,0x75,0x74,0x2e,0x66,0x72,0x61,0x67,
    0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,
    0x6c,0x6f,0x72,0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,
    0x73,0x74,0x61,0x67,0x65,0x5f,0x6f,0x75,0x74,0x70,0x75,0x74,0x3b,0x0a,0x7d,0x0a,
    0x00,
};
#endif /* SOKOL_D3D11 */
#if defined(SOKOL_METAL)
/*
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct pg_vs
    {
        float4x4 u_proj;
    };

    struct main0_out
    {
        float4 color [[user(locn0)]];
        float2 uv [[user(locn1)]];
        float4 gl_Position [[position]];
    };

    struct main0_in
    {
        float3 a_pos [[attribute(0)]];
        float4 a_color [[attribute(1)]];
        float2 a_uv [[attribute(2)]];
    };

    vertex main0_out main0(main0_in in [[stage_in]], constant pg_vs& _21 [[buffer(0)]])
    {
        main0_out out = {};
        out.gl_Position = _21.u_proj * float4(in.a_pos, 1.0);
        out.color = in.a_color;
        out.uv = in.a_uv;
        return out;
    }

*/
static const char vs_source_metal_macos[603] = {
    0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,
    0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,
    0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,
    0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,
    0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x70,
    0x67,0x5f,0x76,0x73,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,
    0x34,0x78,0x34,0x20,0x75,0x5f,0x70,0x72,0x6f,0x6a,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,
    0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,
    0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x63,0x6f,
    0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x30,
    0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,
    0x75,0x76,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x31,0x29,
    0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x67,
    0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x5b,0x5b,0x70,0x6f,0x73,
    0x69,0x74,0x69,0x6f,0x6e,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x73,0x74,0x72,
    0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x0a,0x7b,0x0a,0x20,
    0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x33,0x20,0x61,0x5f,0x70,0x6f,0x73,0x20,
    0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x28,0x30,0x29,0x5d,0x5d,
    0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x61,0x5f,0x63,
    0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,
    0x28,0x31,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,
    0x32,0x20,0x61,0x5f,0x75,0x76,0x20,0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,0x62,0x75,
    0x74,0x65,0x28,0x32,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x76,0x65,0x72,
    0x74,0x65,0x78,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6d,0x61,
    0x69,0x6e,0x30,0x28,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x20,0x69,0x6e,0x20,
    0x5b,0x5b,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x5d,0x5d,0x2c,0x20,0x63,0x6f,
    0x6e,0x73,0x74,0x61,0x6e,0x74,0x20,0x70,0x67,0x5f,0x76,0x73,0x26,0x20,0x5f,0x32,
    0x31,0x20,0x5b,0x5b,0x62,0x75,0x66,0x66,0x65,0x72,0x28,0x30,0x29,0x5d,0x5d,0x29,
    0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,
    0x20,0x6f,0x75,0x74,0x20,0x3d,0x20,0x7b,0x7d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x6f,
    0x75,0x74,0x2e,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3d,
    0x20,0x5f,0x32,0x31,0x2e,0x75,0x5f,0x70,0x72,0x6f,0x6a,0x20,0x2a,0x20,0x66,0x6c,
    0x6f,0x61,0x74,0x34,0x28,0x69,0x6e,0x2e,0x61,0x5f,0x70,0x6f,0x73,0x2c,0x20,0x31,
    0x2e,0x30,0x29,0x3b,0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x63,0x6f,0x6c,
    0x6f,0x72,0x20,0x3d,0x20,0x69,0x6e,0x2e,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,
    0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x75,0x76,0x20,0x3d,0x20,0x69,0x6e,
    0x2e,0x61,0x5f,0x75,0x76,0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,
    0x6e,0x20,0x6f,0x75,0x74,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
/*
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct main0_out
    {
        float4 frag_color [[color(0)]];
    };

    struct main0_in
    {
        float4 color [[user(locn0)]];
        float2 uv [[user(locn1)]];
    };

    fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> u_tex [[texture(0)]], sampler u_texSmplr [[sampler(0)]])
    {
        main0_out out = {};
        out.frag_color = u_tex.sample(u_texSmplr, in.uv) * in.color;
        return out;
    }

*/
static const char fs_source_metal_macos[454] = {
    0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,
    0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,
    0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,
    0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,
    0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,
    0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,
    0x6c,0x6f,0x61,0x74,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,
    0x20,0x5b,0x5b,0x63,0x6f,0x6c,0x6f,0x72,0x28,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,
    0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,
    0x69,0x6e,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,
    0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,
    0x6e,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,
    0x32,0x20,0x75,0x76,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,
    0x31,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x66,0x72,0x61,0x67,0x6d,0x65,
    0x6e,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x28,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x20,0x69,0x6e,0x20,0x5b,
    0x5b,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x5d,0x5d,0x2c,0x20,0x74,0x65,0x78,
    0x74,0x75,0x72,0x65,0x32,0x64,0x3c,0x66,0x6c,0x6f,0x61,0x74,0x3e,0x20,0x75,0x5f,
    0x74,0x65,0x78,0x20,0x5b,0x5b,0x74,0x65,0x78,0x74,0x75,0x72,0x65,0x28,0x30,0x29,
    0x5d,0x5d,0x2c,0x20,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,0x20,0x75,0x5f,0x74,0x65,
    0x78,0x53,0x6d,0x70,0x6c,0x72,0x20,0x5b,0x5b,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,
    0x28,0x30,0x29,0x5d,0x5d,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6f,0x75,0x74,0x20,0x3d,0x20,0x7b,0x7d,0x3b,
    0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,
    0x6c,0x6f,0x72,0x20,0x3d,0x20,0x75,0x5f,0x74,0x65,0x78,0x2e,0x73,0x61,0x6d,0x70,
    0x6c,0x65,0x28,0x75,0x5f,0x74,0x65,0x78,0x53,0x6d,0x70,0x6c,0x72,0x2c,0x20,0x69,
    0x6e,0x2e,0x75,0x76,0x29,0x20,0x2a,0x20,0x69,0x6e,0x2e,0x63,0x6f,0x6c,0x6f,0x72,
    0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x6f,0x75,0x74,
    0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
#endif /* SOKOL_METAL */
#if defined(SOKOL_METAL)
/*
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct pg_vs
    {
        float4x4 u_proj;
    };

    struct main0_out
    {
        float4 color [[user(locn0)]];
        float2 uv [[user(locn1)]];
        float4 gl_Position [[position]];
    };

    struct main0_in
    {
        float3 a_pos [[attribute(0)]];
        float4 a_color [[attribute(1)]];
        float2 a_uv [[attribute(2)]];
    };

    vertex main0_out main0(main0_in in [[stage_in]], constant pg_vs& _21 [[buffer(0)]])
    {
        main0_out out = {};
        out.gl_Position = _21.u_proj * float4(in.a_pos, 1.0);
        out.color = in.a_color;
        out.uv = in.a_uv;
        return out;
    }

*/
static const char vs_source_metal_ios[603] = {
    0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,
    0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,
    0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,
    0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,
    0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x70,
    0x67,0x5f,0x76,0x73,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,
    0x34,0x78,0x34,0x20,0x75,0x5f,0x70,0x72,0x6f,0x6a,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,
    0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,
    0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x63,0x6f,
    0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x30,
    0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,
    0x75,0x76,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x31,0x29,
    0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x67,
    0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x5b,0x5b,0x70,0x6f,0x73,
    0x69,0x74,0x69,0x6f,0x6e,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x73,0x74,0x72,
    0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x0a,0x7b,0x0a,0x20,
    0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x33,0x20,0x61,0x5f,0x70,0x6f,0x73,0x20,
    0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x28,0x30,0x29,0x5d,0x5d,
    0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x61,0x5f,0x63,
    0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,
    0x28,0x31,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,
    0x32,0x20,0x61,0x5f,0x75,0x76,0x20,0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,0x62,0x75,
    0x74,0x65,0x28,0x32,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x76,0x65,0x72,
    0x74,0x65,0x78,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6d,0x61,
    0x69,0x6e,0x30,0x28,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x20,0x69,0x6e,0x20,
    0x5b,0x5b,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x5d,0x5d,0x2c,0x20,0x63,0x6f,
    0x6e,0x73,0x74,0x61,0x6e,0x74,0x20,0x70,0x67,0x5f,0x76,0x73,0x26,0x20,0x5f,0x32,
    0x31,0x20,0x5b,0x5b,0x62,0x75,0x66,0x66,0x65,0x72,0x28,0x30,0x29,0x5d,0x5d,0x29,
    0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,
    0x20,0x6f,0x75,0x74,0x20,0x3d,0x20,0x7b,0x7d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x6f,
    0x75,0x74,0x2e,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3d,
    0x20,0x5f,0x32,0x31,0x2e,0x75,0x5f,0x70,0x72,0x6f,0x6a,0x20,0x2a,0x20,0x66,0x6c,
    0x6f,0x61,0x74,0x34,0x28,0x69,0x6e,0x2e,0x61,0x5f,0x70,0x6f,0x73,0x2c,0x20,0x31,
    0x2e,0x30,0x29,0x3b,0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x63,0x6f,0x6c,
    0x6f,0x72,0x20,0x3d,0x20,0x69,0x6e,0x2e,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,
    0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x75,0x76,0x20,0x3d,0x20,0x69,0x6e,
    0x2e,0x61,0x5f,0x75,0x76,0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,
    0x6e,0x20,0x6f,0x75,0x74,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
/*
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct main0_out
    {
        float4 frag_color [[color(0)]];
    };

    struct main0_in
    {
        float4 color [[user(locn0)]];
        float2 uv [[user(locn1)]];
    };

    fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> u_tex [[texture(0)]], sampler u_texSmplr [[sampler(0)]])
    {
        main0_out out = {};
        out.frag_color = u_tex.sample(u_texSmplr, in.uv) * in.color;
        return out;
    }

*/
static const char fs_source_metal_ios[454] = {
    0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,
    0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,
    0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,
    0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,
    0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,
    0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,
    0x6c,0x6f,0x61,0x74,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,
    0x20,0x5b,0x5b,0x63,0x6f,0x6c,0x6f,0x72,0x28,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,
    0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,
    0x69,0x6e,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,
    0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,
    0x6e,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,
    0x32,0x20,0x75,0x76,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,
    0x31,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x66,0x72,0x61,0x67,0x6d,0x65,
    0x6e,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x28,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x20,0x69,0x6e,0x20,0x5b,
    0x5b,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x5d,0x5d,0x2c,0x20,0x74,0x65,0x78,
    0x74,0x75,0x72,0x65,0x32,0x64,0x3c,0x66,0x6c,0x6f,0x61,0x74,0x3e,0x20,0x75,0x5f,
    0x74,0x65,0x78,0x20,0x5b,0x5b,0x74,0x65,0x78,0x74,0x75,0x72,0x65,0x28,0x30,0x29,
    0x5d,0x5d,0x2c,0x20,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,0x20,0x75,0x5f,0x74,0x65,
    0x78,0x53,0x6d,0x70,0x6c,0x72,0x20,0x5b,0x5b,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,
    0x28,0x30,0x29,0x5d,0x5d,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6f,0x75,0x74,0x20,0x3d,0x20,0x7b,0x7d,0x3b,
    0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,
    0x6c,0x6f,0x72,0x20,0x3d,0x20,0x75,0x5f,0x74,0x65,0x78,0x2e,0x73,0x61,0x6d,0x70,
    0x6c,0x65,0x28,0x75,0x5f,0x74,0x65,0x78,0x53,0x6d,0x70,0x6c,0x72,0x2c,0x20,0x69,
    0x6e,0x2e,0x75,0x76,0x29,0x20,0x2a,0x20,0x69,0x6e,0x2e,0x63,0x6f,0x6c,0x6f,0x72,
    0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x6f,0x75,0x74,
    0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
#endif /* SOKOL_METAL */
#if defined(SOKOL_METAL)
/*
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct pg_vs
    {
        float4x4 u_proj;
    };

    struct main0_out
    {
        float4 color [[user(locn0)]];
        float2 uv [[user(locn1)]];
        float4 gl_Position [[position]];
    };

    struct main0_in
    {
        float3 a_pos [[attribute(0)]];
        float4 a_color [[attribute(1)]];
        float2 a_uv [[attribute(2)]];
    };

    vertex main0_out main0(main0_in in [[stage_in]], constant pg_vs& _21 [[buffer(0)]])
    {
        main0_out out = {};
        out.gl_Position = _21.u_proj * float4(in.a_pos, 1.0);
        out.color = in.a_color;
        out.uv = in.a_uv;
        return out;
    }

*/
static const char vs_source_metal_sim[603] = {
    0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,
    0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,
    0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,
    0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,
    0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x70,
    0x67,0x5f,0x76,0x73,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,
    0x34,0x78,0x34,0x20,0x75,0x5f,0x70,0x72,0x6f,0x6a,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,
    0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,
    0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x63,0x6f,
    0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x30,
    0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,
    0x75,0x76,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x31,0x29,
    0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x67,
    0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x5b,0x5b,0x70,0x6f,0x73,
    0x69,0x74,0x69,0x6f,0x6e,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x73,0x74,0x72,
    0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x0a,0x7b,0x0a,0x20,
    0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x33,0x20,0x61,0x5f,0x70,0x6f,0x73,0x20,
    0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x28,0x30,0x29,0x5d,0x5d,
    0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x61,0x5f,0x63,
    0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,
    0x28,0x31,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,
    0x32,0x20,0x61,0x5f,0x75,0x76,0x20,0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,0x62,0x75,
    0x74,0x65,0x28,0x32,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x76,0x65,0x72,
    0x74,0x65,0x78,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6d,0x61,
    0x69,0x6e,0x30,0x28,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x20,0x69,0x6e,0x20,
    0x5b,0x5b,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x5d,0x5d,0x2c,0x20,0x63,0x6f,
    0x6e,0x73,0x74,0x61,0x6e,0x74,0x20,0x70,0x67,0x5f,0x76,0x73,0x26,0x20,0x5f,0x32,
    0x31,0x20,0x5b,0x5b,0x62,0x75,0x66,0x66,0x65,0x72,0x28,0x30,0x29,0x5d,0x5d,0x29,
    0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,
    0x20,0x6f,0x75,0x74,0x20,0x3d,0x20,0x7b,0x7d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x6f,
    0x75,0x74,0x2e,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3d,
    0x20,0x5f,0x32,0x31,0x2e,0x75,0x5f,0x70,0x72,0x6f,0x6a,0x20,0x2a,0x20,0x66,0x6c,
    0x6f,0x61,0x74,0x34,0x28,0x69,0x6e,0x2e,0x61,0x5f,0x70,0x6f,0x73,0x2c,0x20,0x31,
    0x2e,0x30,0x29,0x3b,0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x63,0x6f,0x6c,
    0x6f,0x72,0x20,0x3d,0x20,0x69,0x6e,0x2e,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,
    0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x75,0x76,0x20,0x3d,0x20,0x69,0x6e,
    0x2e,0x61,0x5f,0x75,0x76,0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,
    0x6e,0x20,0x6f,0x75,0x74,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
/*
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct main0_out
    {
        float4 frag_color [[color(0)]];
    };

    struct main0_in
    {
        float4 color [[user(locn0)]];
        float2 uv [[user(locn1)]];
    };

    fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> u_tex [[texture(0)]], sampler u_texSmplr [[sampler(0)]])
    {
        main0_out out = {};
        out.frag_color = u_tex.sample(u_texSmplr, in.uv) * in.color;
        return out;
    }

*/
static const char fs_source_metal_sim[454] = {
    0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,
    0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,
    0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,
    0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,
    0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,
    0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,
    0x6c,0x6f,0x61,0x74,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,
    0x20,0x5b,0x5b,0x63,0x6f,0x6c,0x6f,0x72,0x28,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,
    0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,
    0x69,0x6e,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,
    0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,
    0x6e,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,
    0x32,0x20,0x75,0x76,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,
    0x31,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x66,0x72,0x61,0x67,0x6d,0x65,
    0x6e,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x28,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x20,0x69,0x6e,0x20,0x5b,
    0x5b,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x5d,0x5d,0x2c,0x20,0x74,0x65,0x78,
    0x74,0x75,0x72,0x65,0x32,0x64,0x3c,0x66,0x6c,0x6f,0x61,0x74,0x3e,0x20,0x75,0x5f,
    0x74,0x65,0x78,0x20,0x5b,0x5b,0x74,0x65,0x78,0x74,0x75,0x72,0x65,0x28,0x30,0x29,
    0x5d,0x5d,0x2c,0x20,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,0x20,0x75,0x5f,0x74,0x65,
    0x78,0x53,0x6d,0x70,0x6c,0x72,0x20,0x5b,0x5b,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,
    0x28,0x30,0x29,0x5d,0x5d,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6f,0x75,0x74,0x20,0x3d,0x20,0x7b,0x7d,0x3b,
    0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,
    0x6c,0x6f,0x72,0x20,0x3d,0x20,0x75,0x5f,0x74,0x65,0x78,0x2e,0x73,0x61,0x6d,0x70,
    0x6c,0x65,0x28,0x75,0x5f,0x74,0x65,0x78,0x53,0x6d,0x70,0x6c,0x72,0x2c,0x20,0x69,
    0x6e,0x2e,0x75,0x76,0x29,0x20,0x2a,0x20,0x69,0x6e,0x2e,0x63,0x6f,0x6c,0x6f,0x72,
    0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x6f,0x75,0x74,
    0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
#endif /* SOKOL_METAL */
static const sg_shader_desc* pg_default_shader_desc(sg_backend backend) {
  #if defined(SOKOL_GLCORE33)
  if (backend == SG_BACKEND_GLCORE33) {
    static sg_shader_desc desc;
    static bool valid;
    if (!valid) {
      valid = true;
      desc.attrs[0].name = "a_pos";
      desc.attrs[1].name = "a_color";
      desc.attrs[2].name = "a_uv";
      desc.vs.source = vs_source_glsl330;
      desc.vs.entry = "main";
      desc.vs.uniform_blocks[0].size = 64;
      desc.vs.uniform_blocks[0].layout = SG_UNIFORMLAYOUT_STD140;
      desc.vs.uniform_blocks[0].uniforms[0].name = "pg_vs";
      desc.vs.uniform_blocks[0].uniforms[0].type = SG_UNIFORMTYPE_FLOAT4;
      desc.vs.uniform_blocks[0].uniforms[0].array_count = 4;
      desc.fs.source = fs_source_glsl330;
      desc.fs.entry = "main";
      desc.fs.images[0].name = "u_tex";
      desc.fs.images[0].image_type = SG_IMAGETYPE_2D;
      desc.fs.images[0].sampler_type = SG_SAMPLERTYPE_FLOAT;
      desc.label = "pg_default_shader";
    }
    return &desc;
  }
  #endif /* SOKOL_GLCORE33 */
  #if defined(SOKOL_GLES3)
  if (backend == SG_BACKEND_GLES3) {
    static sg_shader_desc desc;
    static bool valid;
    if (!valid) {
      valid = true;
      desc.attrs[0].name = "a_pos";
      desc.attrs[1].name = "a_color";
      desc.attrs[2].name = "a_uv";
      desc.vs.source = vs_source_glsl300es;
      desc.vs.entry = "main";
      desc.vs.uniform_blocks[0].size = 64;
      desc.vs.uniform_blocks[0].layout = SG_UNIFORMLAYOUT_STD140;
      desc.vs.uniform_blocks[0].uniforms[0].name = "pg_vs";
      desc.vs.uniform_blocks[0].uniforms[0].type = SG_UNIFORMTYPE_FLOAT4;
      desc.vs.uniform_blocks[0].uniforms[0].array_count = 4;
      desc.fs.source = fs_source_glsl300es;
      desc.fs.entry = "main";
      desc.fs.images[0].name = "u_tex";
      desc.fs.images[0].image_type = SG_IMAGETYPE_2D;
      desc.fs.images[0].sampler_type = SG_SAMPLERTYPE_FLOAT;
      desc.label = "pg_default_shader";
    }
    return &desc;
  }
  #endif /* SOKOL_GLES3 */
  #if defined(SOKOL_D3D11)
  if (backend == SG_BACKEND_D3D11) {
    static sg_shader_desc desc;
    static bool valid;
    if (!valid) {
      valid = true;
      desc.attrs[0].sem_name = "TEXCOORD";
      desc.attrs[0].sem_index = 0;
      desc.attrs[1].sem_name = "TEXCOORD";
      desc.attrs[1].sem_index = 1;
      desc.attrs[2].sem_name = "TEXCOORD";
      desc.attrs[2].sem_index = 2;
      desc.vs.source = vs_source_hlsl5;
      desc.vs.d3d11_target = "vs_5_0";
      desc.vs.entry = "main";
      desc.vs.uniform_blocks[0].size = 64;
      desc.vs.uniform_blocks[0].layout = SG_UNIFORMLAYOUT_STD140;
      desc.fs.source = fs_source_hlsl5;
      desc.fs.d3d11_target = "ps_5_0";
      desc.fs.entry = "main";
      desc.fs.images[0].name = "u_tex";
      desc.fs.images[0].image_type = SG_IMAGETYPE_2D;
      desc.fs.images[0].sampler_type = SG_SAMPLERTYPE_FLOAT;
      desc.label = "pg_default_shader";
    }
    return &desc;
  }
  #endif /* SOKOL_D3D11 */
  #if defined(SOKOL_METAL)
  if (backend == SG_BACKEND_METAL_MACOS) {
    static sg_shader_desc desc;
    static bool valid;
    if (!valid) {
      valid = true;
      desc.vs.source = vs_source_metal_macos;
      desc.vs.entry = "main0";
      desc.vs.uniform_blocks[0].size = 64;
      desc.vs.uniform_blocks[0].layout = SG_UNIFORMLAYOUT_STD140;
      desc.fs.source = fs_source_metal_macos;
      desc.fs.entry = "main0";
      desc.fs.images[0].name = "u_tex";
      desc.fs.images[0].image_type = SG_IMAGETYPE_2D;
      desc.fs.images[0].sampler_type = SG_SAMPLERTYPE_FLOAT;
      desc.label = "pg_default_shader";
    }
    return &desc;
  }
  #endif /* SOKOL_METAL */
  #if defined(SOKOL_METAL)
  if (backend == SG_BACKEND_METAL_IOS) {
    static sg_shader_desc desc;
    static bool valid;
    if (!valid) {
      valid = true;
      desc.vs.source = vs_source_metal_ios;
      desc.vs.entry = "main0";
      desc.vs.uniform_blocks[0].size = 64;
      desc.vs.uniform_blocks[0].layout = SG_UNIFORMLAYOUT_STD140;
      desc.fs.source = fs_source_metal_ios;
      desc.fs.entry = "main0";
      desc.fs.images[0].name = "u_tex";
      desc.fs.images[0].image_type = SG_IMAGETYPE_2D;
      desc.fs.images[0].sampler_type = SG_SAMPLERTYPE_FLOAT;
      desc.label = "pg_default_shader";
    }
    return &desc;
  }
  #endif /* SOKOL_METAL */
  #if defined(SOKOL_METAL)
  if (backend == SG_BACKEND_METAL_SIMULATOR) {
    static sg_shader_desc desc;
    static bool valid;
    if (!valid) {
      valid = true;
      desc.vs.source = vs_source_metal_sim;
      desc.vs.entry = "main0";
      desc.vs.uniform_blocks[0].size = 64;
      desc.vs.uniform_blocks[0].layout = SG_UNIFORMLAYOUT_STD140;
      desc.fs.source = fs_source_metal_sim;
      desc.fs.entry = "main0";
      desc.fs.images[0].name = "u_tex";
      desc.fs.images[0].image_type = SG_IMAGETYPE_2D;
      desc.fs.images[0].sampler_type = SG_SAMPLERTYPE_FLOAT;
      desc.label = "pg_default_shader";
    }
    return &desc;
  }
  #endif /* SOKOL_METAL */
  return 0;
}
static int pg_default_attr_slot(const char* attr_name) {
  (void)attr_name;
  if (0 == strcmp(attr_name, "a_pos")) {
    return 0;
  }
  if (0 == strcmp(attr_name, "a_color")) {
    return 1;
  }
  if (0 == strcmp(attr_name, "a_uv")) {
    return 2;
  }
  return -1;
}
static int pg_default_image_slot(sg_shader_stage stage, const char* img_name) {
  (void)stage; (void)img_name;
  if (SG_SHADERSTAGE_FS == stage) {
    if (0 == strcmp(img_name, "u_tex")) {
      return 0;
    }
  }
  return -1;
}
static int pg_default_uniformblock_slot(sg_shader_stage stage, const char* ub_name) {
  (void)stage; (void)ub_name;
  if (SG_SHADERSTAGE_VS == stage) {
    if (0 == strcmp(ub_name, "pg_vs")) {
      return 0;
    }
  }
  return -1;
}
static size_t pg_default_uniformblock_size(sg_shader_stage stage, const char* ub_name) {
  (void)stage; (void)ub_name;
  if (SG_SHADERSTAGE_VS == stage) {
    if (0 == strcmp(ub_name, "pg_vs")) {
      return sizeof(pg_vs_t);
    }
  }
  return 0;
}
static int pg_default_uniform_offset(sg_shader_stage stage, const char* ub_name, const char* u_name) {
  (void)stage; (void)ub_name; (void)u_name;
  if (SG_SHADERSTAGE_VS == stage) {
    if (0 == strcmp(ub_name, "pg_vs")) {
      if (0 == strcmp(u_name, "u_proj")) {
        return 0;
      }
    }
  }
  return -1;
}
static sg_shader_uniform_desc pg_default_uniform_desc(sg_shader_stage stage, const char* ub_name, const char* u_name) {
  (void)stage; (void)ub_name; (void)u_name;
  #if defined(__cplusplus)
  sg_shader_uniform_desc desc = {};
  #else
  sg_shader_uniform_desc desc = {0};
  #endif
  if (SG_SHADERSTAGE_VS == stage) {
    if (0 == strcmp(ub_name, "pg_vs")) {
      if (0 == strcmp(u_name, "u_proj")) {
        desc.name = "u_proj";
        desc.type = SG_UNIFORMTYPE_MAT4;
        desc.array_count = 1;
        return desc;
      }
    }
  }
  return desc;
}

#endif //PICO_GFX_IMPLEMENTATION